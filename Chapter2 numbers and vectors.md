# Chapter 2 Numbers and Vectors
[原书链接](https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf)
### vectors and assignment
在学习R之前，我只接触过C和Python两种语言，因此会觉得R的赋值
（assignment）很特殊。R有四种赋值方式：
```r
# assignment statements

> x<-4
> 4->x
> assign("x",4)
> x=4
```
"<-"和“=”在大部分情况下作用相同，但也有一些情景中
它们俩不能替换。具体的区别书里还没讲，打算多学一点
后再去研究^o^

在R语言里，*vector*是最简单的数据结构。新建一个*vector*的代码如下：
```r
# set up a vector named x

> x<-c(2,5,3)
> x
[1] 2 5 3
```
这里的c函数c()可以把括号里的多个对象连接在一起，
组成向量*vector*。c为concatenate（连接）的缩写。

### vector arithmetic
*vector*还可以继续进行赋值和运算，比如：

```r
# assignment

> x<-c(2,5,3)
> y<-c(1,x,2)
> y
[1] 1 2 5 3 2

# addition

> z<-x+1
> z
[1] 3 6 4

#mulplication

> t<-2*x
> t
[1]  4 10  6
```
接下来是关于两个向量之间的运算，这就比较有意思了。
如果两个向量的长度相等，它们之间的运算就很好理解，
对应位置上的数字进项运算即可。比如：
```r
> x<-c(1,2,3)
> y<-c(5,6,7)
> x*y
[1]  5 12 21
```
但如果两个向量的长度不相等，那能否进行运算呢？
```r
> x<-c(1,2,3)
> y<-c(3,5)
> x*y
[1]  3 10  9
Warning message:
In x * y : 长的对象长度不是短的对象长度的整倍数
```
从以上的例子可以看出来，即使长度不相等，
它们也是可以进行运算的，
最后得出的结果向量的长度与较长向量长度相等，
较短向量里的所有数字都运算结束后，又会回到开头，进行循环。
但是程序中跳出了warning，我们再试一次：
```r
> x<-c(2,3)
> y<-c(3,6,5,2)
> x*y
[1]  6 18 10  6
```
这次向量y的长度是向量x的整数倍，程序没有跳出warning。
但不管怎么样，基本原则都是最终结果向量的长度与较长向量一致，
较短向量在运算过程中以循环的方式来和较长向量进行运算。
当较长向量的长度不是较短向量的整数倍时，程序会跳出警告，
但是不影响运算。此时虽然可以运算出结果，但是这样的两个向量相乘，
其实是没有数学意义的。

接下来是一些运算符，这在很多语言中都是通用的。log()、
sqrt()、exp()、min()、max()、length()、mean()……
可能不太熟悉的有sort()、range()以及pmax()/pmin()：
```r
# 按从小到大顺序排序

> x<-c(3,6,1,9)
> sort(x)
[1] 1 3 6 9

# range()返回由最小值和最大值组成的向量

> range(x)
[1] 1 9

# pmin

> pmin(2:4,4:2)
[1] 2 3 2
```
pmin()返回的向量长度和原向量中长度最大的参数保持一致，
在上述代码中最大长度即为3。pmin(2:4,4:2)比较的是
(2,3,4)和(4,3,2)，返回的向量对应位置上的数字即为两个参数对应位置上最小的那个。
因此返回向量的第一个参数为min(2,4)，第二个参数为min(3,3)，第三个参数为min(4,2)。

### generating regular sequences
这里讲的是如何生成序列。其实上文提到了其中简单的一点：
```r
#  用冒号生成连续序列

> (2:4)
[1] 2 3 4
```
这很好理解啦，值得注意的是在运算过程中，
冒号的优先级高于四则运算：
```r
# 冒号的优先级

> x<-4
> 1:x-1
[1] 0 1 2 3
> 1:(x-1)
[1] 1 2 3
```
第二个生成序列的常用方法是seq()函数，该函数共有5个参数:
```r
# to&from

> seq(2,5)
[1] 2 3 4 5
> seq(from=2,to=5)
[1] 2 3 4 5
> seq(to=5,from=2)
[1] 2 3 4 5
> seq(to=2,5)
[1] 5 4 3 2
> seq(from=2,5)
[1] 2 3 4 5

# by

> seq(2,11,by=3)
[1]  2  5  8 11

# length

seq(from=3,by=2,length=5)
[1]  3  5  7  9 11

# along 生成与along后面的向量长度相等的向量

> seq(1,5,along='er')
[1] 1
> seq(3,8,along=c(1,2))
[1] 3 8
```
和生成序列相关的另一个函数是rep()，它并不是严格意义上的生成序列，只是起到repeat作用。
rep()有以下两种用法：
```r
> x<-c(3,5,2)

# 将向量重复5次

> rep(x,times=5)
 [1] 3 5 2 3 5 2 3 5 2 3 5 2 3 5 2
 > rep(x,5)
 [1] 3 5 2 3 5 2 3 5 2 3 5 2 3 5 2

 # 将向量里的每个元素依次重复5次

> rep(x,each=5)
 [1] 3 3 3 3 3 5 5 5 5 5 2 2 2 2 2
```
当省略到括号里的文字时，默认的就是times，当然也可以重复单独的字符：
```r
> rep("e",20)
 [1] "e" "e" "e" "e" "e" "e" "e" "e" "e" "e" "e" "e" "e" "e" "e" "e" "e" "e"
[19] "e" "e"
```
### logical vectors

除了*numerical vectors*, R里还有*logical vectors*。逻辑向量里包含3个*element*，**TRUE**，
**FALSE**，**NA**。
布尔运算符和很多其他语言都是通用的，比较运算符<,<=,>,>=,==,!=；与运算符&，或运算符|，非运算符！。

### missing values
当向量中的某些元素缺失时，该元素就被赋予一个特殊的值NA。任何关于NA的运算，结果都是NA。
接下来有一个关于NA的函数**is.na()**:
```r
> x<-c(3,5,4,NA)
> y<-is.na(x)
> y
[1] FALSE FALSE FALSE  TRUE
```
该函数返回一个和x等长的向量，与x里的NA对应位置上的元素值为TRUE，其他均为FALSE。
还有一种缺失的情况，仅针对数字，即**NaN(Not a Number)**。
```r
> 0/0
[1] NaN
```
与之对应的，is.nan()的逻辑和is.na()类似，值得注意的是，当值为NA和NaN时，is.na()返回的值均为TRUE。

### character vectors
通过c()，可以将任意数量的字符向量连接成向量。
接下来介绍新函数paste()，它可以将任意数量的参数连接成字符串。
这个函数的基本结构是paste(...,sep="",collapse=NULL)。collapse参数暂时用不上（我也还没搞懂），
先介绍一下这个函数的简单用法。
```r
# 连接两个字符

> paste("w","r")
[1] "w r"

# sep设置两个字符之间的分隔符

> paste("w","r",sep="-")
[1] "w-r"

# 两组字符相连

> paste(c("w","r"),1:4)
[1] "w 1" "r 2" "w 3" "r 4"

# sep设置两组字符之间的分隔符

> paste(c("w","r"),1:4,sep="-")
[1] "w-1" "r-2" "w-3" "r-4"
```
### index vectors
顾名思义，索引向量指向的是某个向量中的部分元素，它通常被放在向量名后面的方括号[]里。索引向量分为以下四类：
1. **a logical vector**
```r
> x<-c(3,6,2,NA,1,NaN,55)
> x
[1]   3   6   2  NA   1 NaN  55
> x[!is.na(x)]
[1]  3  6  2  1 55
```
2. **a vector of positive integral quantities**
```r
> x<-c(3,5,2,7,5,4,3)
> x[4]
[1] 7
> x[2:5]
[1] 5 2 7 5
```
3. **a vector of negative integral quantities**
```r
> x<-c(3,6,5,1,76,32,16)
# 去掉第三个数字
> x[-3]
[1]  3  6  1 76 32 16
#去掉第2到第5个数字
> x[-(2:5)]
[1]  3 32 16
```
4. **a vector of character strings**  
这个还蛮有趣的，我根据我的理解来举一个例子。去超市买菜，
比如说娃娃菜10块钱，番茄15块钱，土豆7块钱，大蒜3块钱，我只想买番茄和土豆。在超市里，
收银员给我结账时ta并不需要记下所有商品的价格，只需要扫一下barcode，
机器上就自动出现价格。
```r
> veg<-c(10,15,7,3)
> names(veg)<-c("cabbage","tomato","potato","garlic")
> order<-veg[c("tomato","potato")]
> order
tomato potato 
    15      7 
```
